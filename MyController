




///have some way to indicate that it is collapse/expanded

//comparison box?

//way to filter

class MyController {
  MyNode hover;
  MyNode selectedNode;

  boolean buttons;
  boolean showingBox; //state of showing the control box

    float boxX;
  float boxY;
  float boxWidth;
  float boxHeight;

  float buttonx;
  float collapseY;
  float expandY;
  float centerY;
  float filterY;

  float buttonHeight;
  float buttonWidth;

  ArrayList labels;
  float textBoxWidth;


  public MyController(ArrayList initTreeLabels, float textBox) {
    this.labels = initTreeLabels;
    this.buttons = false;
    this.showingBox = false;
    this.textBoxWidth = textBox + 5;

    this.boxX = 20;
    this.boxY = 20;
    this.boxWidth = 200;
    this.boxHeight = 250;

    this.buttonHeight = 30;
    this.buttonWidth = this.boxWidth - 20;

    this.buttonx = this.boxX + 10;
    this.collapseY = this.boxY + 10;
    this.expandY = this.boxY + 20 + this.buttonHeight;
    this.centerY = this.boxY + 30 + 2*this.buttonHeight;
    this.filterY = this.boxY + 40 + 3*this.buttonHeight;
  }


  void run(MyNode start) {

    this.hover = highlight(start);
    if (this.hover != null) {
      if (this.selectedNode != null) {
        this.selectedNode.selected = false;
      }
      this.selectedNode = this.hover;
      this.selectedNode.selected = true;
    }
    //open box
    if (this.hover != null && this.showingBox == false) {
      this.showingBox = true;
    }

    //close box
    else if (this.hover == null && this.showingBox == true && this.boxIsect() == false) {
      this.showingBox = false;
      this.selectedNode.selected = false;
    }
  }


  boolean boxIsect() {
    float xDist = mouseX - this.boxX; 
    float yDist = mouseY - this.boxY;
    if ((xDist < this.boxWidth) && (yDist < this.boxHeight) && (xDist > 0) && (yDist > 0)) {
      return true;
    }
    return false;
  }

  MyNode highlight(MyNode start) {
    if (start.circle.isBounded()) {
      return start;
    }
    if (!start.leaf) {
      for (int i = 0; i < start.children.size(); i++) {
        if (highlight((MyNode)start.children.get(i)) != null) {
          return highlight((MyNode) start.children.get(i));
        }
      }
    }
    return null;
  }

  void renderBox() {
    fill(150, 150, 150, 220);
    noStroke();
    rect(this.boxX, this.boxY, this.boxWidth, this.boxHeight, 8);  //main control square

    fill(100);
    rect(this.buttonx, this.collapseY, this.buttonWidth, this.buttonHeight, 8);
    rect(this.buttonx, this.expandY, this.buttonWidth, this.buttonHeight, 8);
    rect(this.buttonx, this.centerY, this.buttonWidth, this.buttonHeight, 8);
    rect(this.buttonx, this.filterY, this.buttonWidth, this.buttonHeight, 8);

    fill(255);
    textSize(15);
    textAlign(CENTER);
    text("COLLAPSE", .5*(this.boxWidth + this.boxX), this.boxY + this.buttonHeight);
    text("EXPAND", .5*(this.boxWidth + this.boxX), this.boxY + 2*this.buttonHeight + 10);
    text("CENTER", .5*(this.boxWidth + this.boxX), this.boxY + 3*this.buttonHeight + 20);
    text("FILTER", .5*(this.boxWidth + this.boxX), this.boxY + 4*this.buttonHeight + 30);

    text("CLICK OFF TO CLOSE BOX", .5*(this.boxWidth + this.boxX + 10), this.boxY + 6*this.buttonHeight);
    text("SELECTED NODE: " + this.selectedNode.id, .5*(this.boxWidth + this.boxX + 10), this.boxY + 7*this.buttonHeight);
  }

  void buttonIsect() {
    if (buttonIsect(this.collapseY)) {
      println("collapse");
      if (this.selectedNode != mytree.current) {
        this.selectedNode.collapse = true;
      }
    }
    if (buttonIsect(this.expandY) && (this.selectedNode.collapse)) {
      this.selectedNode.collapse = false;
      return;
    }
    if (buttonIsect(this.centerY)) {
      println("center pressed");
      mytree.center(this.selectedNode);
    }
    if (buttonIsect(this.filterY)) {
      println("filter");
      this.filterNodes(mytree.root);
    }
  }

  boolean buttonIsect(float _y) {
    float xDist = mouseX - this.buttonx; 
    float yDist = mouseY - _y;
    if ((xDist < this.buttonWidth) && (yDist < this.buttonHeight) && (xDist > 0) && (yDist > 0)) {
      return true;
    }
    return false;
  }



  void showInfo(MyNode start) {
    MyNode hover = highlight(start);

    if (hover != null) {
      //node with just one reaction type;
      float _x = mouseX + 5;
      float _y;
      float _height;
      if (hover.details.oneType) {
        _y = mouseY - 105;
        if (mouseX > (width - hover.details.textBoxWidth)) {
          _x = mouseX - hover.details.textBoxWidth - 5;
        }
        if (mouseY < (height - 105)) {
          _y = mouseY - 105;
        }

        fill(150, 150, 150, 220);
        noStroke();
        rect(_x, _y, hover.details.textBoxWidth, 100, 9);

        fill(255);
        textSize(12);
        textAlign(LEFT);
        text("ID: " + hover.id + "\nSize: " + hover.details.numReactions + 
          "\n" + hover.details.oneClass + " 100%", _x + 5, _y + 3, hover.details.textBoxWidth, 100);
      }
      //node with more than one reaction type 
      else {
        _x = mouseX + 5;
        _y = mouseY - 100;
        if (mouseX > (width - this.textBoxWidth)) {
          _x = mouseX - this.textBoxWidth - 5;
        }
        if (mouseY < (height - 100)) {
          _y = mouseY - 100;
        }

        fill(150, 150, 150, 220);
        noStroke();
        rect(_x, _y, this.textBoxWidth + 5, 100, 9);

        fill(255);
        textSize(12);
        textAlign(LEFT);
        text("ID: " + hover.id + "  Size: " + hover.details.numReactions, _x + 5, _y + 15);
        float curr_height = _y + 25;
        for (int i = 0; i < this.labels.size(); i++) {
          text((String) this.labels.get(i) + ": " + hover.details.proportions[i] + "%" , _x + 5, curr_height);
          curr_height = curr_height + 14;
        }
      }
    }
  }




  ////FILTERING 

  void filterNodes(MyNode start) {
  }
}
